import std/[unittest, strutils, tables]
import treestand

type
  Env = object
    vars: Table[string, int]

tsGrammar "calc", userdata: Env:  
  root    <- +assign:
    # Iterate using node API
    echo "Root has " & $node.childCount() & " children:"
    for child in node.children:
       echo "  Child " & node.kind & ": " & child.text

  assign  <- (env_name : ident) * eq * number * semi:
    # Use manual indexing or helper
    # assign has children: ident, eq, number, semi
    # 0 based indexing in parser_runtime
    # ident is 0, number is 2
    
    # Or use child by name:
    let idNode = node.child("ident")
    let numNode = node.child("number")
    
    if idNode != nil and numNode != nil:
      let varName = idNode.text
      let val = parseInt(numNode.text)
      
      userdata.vars[varName] = val
      echo "Assigned " & varName & " = " & $val

  ident   <- token(re"[a-zA-Z_][a-zA-Z0-9_]*"):
    echo "Found Ident: " & node.text
  number  <- token(re"\d+")
  eq      <- token("=")
  semi    <- token(";")

test "Simple Assignment Grammar with Actions":
  var env = Env()
  env.vars = initTable[string, int]()
  
  let code = """
    x = 10;
    y = 20;
    z = 30;
  """
  
  # matchCalc is generated by tsGrammar
  if matchCalc(code, env):
    echo "Parsed successfully!"
    check env.vars.len == 3
    check env.vars["x"] == 10
    check env.vars["y"] == 20
    check env.vars["z"] == 30
  else:
    echo "Parsing failed!"
    fail()
