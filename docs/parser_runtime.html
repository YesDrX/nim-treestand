<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>docs/parser_runtime</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.4">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.4"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">docs/parser_runtime</h1>
      
<h1 id="parser-runtime-api-reference">Parser Runtime API Reference</h1><p>This document describes the runtime API available in generated parsers. The <tt class="docutils literal"><span class="pre">parser_runtime.nim</span></tt> file is <strong>included</strong> (not imported) into generated parsers, making all these functions directly available.</p>

<h2 id="overview">Overview</h2><p>The parser runtime provides:</p>
<ul class="simple"><li><strong>Symbol introspection</strong>: Get names and metadata for grammar symbols</li>
<li><strong>Tree printing</strong>: Convert parse trees to readable formats (S-expressions, indented text)</li>
<li><strong>Tree traversal</strong>: Walk and query the parse tree</li>
<li><strong>GLR parsing</strong>: Generic GLR parser with error recovery</li>
<li><strong>Convenience API</strong>: High-level node access methods</li>
<li><strong>Corpus generation</strong>: Write test cases to corpus files</li>
</ul>
<p>---</p>

<h2 id="symbol-utilities">Symbol Utilities</h2>
<h3 id="symbolname"><tt class="docutils literal"><span class="pre">symbolName</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">symbolName</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Identifier">Symbol</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>Get the human-readable name of a symbol for debugging.</p>
<p><strong>Returns:</strong></p>
<ul class="simple"><li>Terminal symbols: Returns the terminal name (e.g., <tt class="docutils literal"><span class="pre">&quot;number&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;tsEOF&quot;</span></tt>)</li>
<li>Non-terminal symbols: Returns the non-terminal name (e.g., <tt class="docutils literal"><span class="pre">&quot;expression&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;statement&quot;</span></tt>)</li>
<li>Error symbols: Returns <tt class="docutils literal"><span class="pre">&quot;&lt;error&gt;&quot;</span></tt></li>
<li>Unknown symbols: Returns <tt class="docutils literal"><span class="pre">&quot;&lt;unknown terminal N&gt;&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;&lt;unknown non-terminal N&gt;&quot;</span></tt></li>
</ul>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">node</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">parse</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">symbolName</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">symbol</span><span class="Punctuation">)</span>  <span class="Comment"># &quot;program&quot;</span></pre></p>

<h3 id="isnamed"><tt class="docutils literal"><span class="pre">isNamed</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">isNamed</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">sym</span><span class="Punctuation">:</span> <span class="Identifier">Symbol</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre></p>
<p>Check if a symbol represents a <strong>named node</strong> in the parse tree.</p>
<p><strong>Returns:</strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">true</span></tt> for named terminals (e.g., <tt class="docutils literal"><span class="pre">identifier</span></tt>, <tt class="docutils literal"><span class="pre">number</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">true</span></tt> for all non-terminals</li>
<li><tt class="docutils literal"><span class="pre">false</span></tt> for anonymous tokens (e.g., <tt class="docutils literal"><span class="pre">&quot;{&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;+&quot;</span></tt>, keywords)</li>
<li><tt class="docutils literal"><span class="pre">false</span></tt> for error nodes</li>
</ul>
<p><strong>Use case:</strong> Filter out punctuation/keywords when traversing only semantic nodes.</p>
<p>---</p>

<h2 id="tree-printing">Tree Printing</h2>
<h3 id="dollar-tostring"><tt class="docutils literal"><span class="pre">$</span></tt> (ToString)</h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">$</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>Convert a parse node to an indented string representation for debugging.</p>
<p><strong>Format:</strong></p>
<p><pre class="listing">program
  statement
    expression
      number &quot;42&quot; [0-2]</pre></p>
<ul class="simple"><li>Shows hierarchical structure with indentation</li>
<li>Leaf nodes show: <tt class="docutils literal"><span class="pre">name text [startPos-endPos]</span></tt></li>
<li>Regex patterns (starting with <tt class="docutils literal"><span class="pre">/</span></tt>) are hidden for clarity</li>
</ul>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">parse</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">tree</span>  <span class="Comment"># Prints indented tree</span></pre></p>

<h3 id="tosexpr"><tt class="docutils literal"><span class="pre">toSExpr</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">toSExpr</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">indent</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>Convert parse node to pretty S-expression format (tree-sitter compatible).</p>
<p><strong>Format:</strong></p>
<p><pre class="listing">(program
  (statement
    (expression
      (number &quot;42&quot;))))</pre></p>
<p><strong>Parameters:</strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">node</span></tt>: The parse node to convert</li>
<li><tt class="docutils literal"><span class="pre">indent</span></tt>: Starting indentation level (default: 0)</li>
</ul>
<p><strong>Use case:</strong> Generate expected output for corpus tests, compare with tree-sitter parsers.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">parse</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">toSExpr</span><span class="Punctuation">(</span><span class="Identifier">tree</span><span class="Punctuation">)</span>
<span class="Comment"># Or with custom indent:</span>
<span class="Identifier">echo</span> <span class="Identifier">toSExpr</span><span class="Punctuation">(</span><span class="Identifier">tree</span><span class="Punctuation">,</span> <span class="Identifier">indent</span> <span class="Operator">=</span> <span class="DecNumber">2</span><span class="Punctuation">)</span></pre></p>
<p>---</p>

<h2 id="tree-traversal">Tree Traversal</h2>
<h3 id="walktree"><tt class="docutils literal"><span class="pre">walkTree</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">walkTree</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">visit</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span></pre></p>
<p>Walk the parse tree in <strong>pre-order</strong> (parent before children), calling <tt class="docutils literal"><span class="pre">visit</span></tt> for each node.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">walkTree</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">kind</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="StringLit">&quot;: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">text</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span></pre></p>

<h3 id="findnodes"><tt class="docutils literal"><span class="pre">findNodes</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">findNodes</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">predicate</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">ParseNode</span><span class="Punctuation">]</span></pre></p>
<p>Find all nodes matching a predicate function.</p>
<p><strong>Returns:</strong> Sequence of all matching nodes</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Comment"># Find all number literals</span>
<span class="Keyword">let</span> <span class="Identifier">numbers</span> <span class="Operator">=</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">findNodes</span> <span class="Keyword">do</span> <span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span> <span class="Operator">-&gt;</span> <span class="Identifier">bool</span><span class="Punctuation">:</span>
  <span class="Identifier">kind</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span> <span class="Operator">==</span> <span class="StringLit">&quot;number&quot;</span>

<span class="Keyword">for</span> <span class="Identifier">num</span> <span class="Keyword">in</span> <span class="Identifier">numbers</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Found number: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">text</span><span class="Punctuation">(</span><span class="Identifier">num</span><span class="Punctuation">)</span></pre></p>

<h3 id="findnodesbysymbol"><tt class="docutils literal"><span class="pre">findNodesBySymbol</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">findNodesBySymbol</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">symbolNameToFind</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">ParseNode</span><span class="Punctuation">]</span></pre></p>
<p>Find all nodes with a specific symbol name.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">node</span></tt>: Root node to search from</li>
<li><tt class="docutils literal"><span class="pre">symbolNameToFind</span></tt>: Exact symbol name to match (e.g., <tt class="docutils literal"><span class="pre">&quot;identifier&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;function_definition&quot;</span></tt>)</li>
</ul>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Comment"># Find all function calls</span>
<span class="Keyword">let</span> <span class="Identifier">calls</span> <span class="Operator">=</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">findNodesBySymbol</span><span class="Punctuation">(</span><span class="StringLit">&quot;function_call&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">for</span> <span class="Identifier">call</span> <span class="Keyword">in</span> <span class="Identifier">calls</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Function call at: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">call</span><span class="Operator">.</span><span class="Identifier">startPos</span></pre></p>
<p>---</p>

<h2 id="glr-parser-runtime">GLR Parser Runtime</h2>
<h3 id="rungenericglr"><tt class="docutils literal"><span class="pre">runGenericGLR</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">runGenericGLR</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">parser</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Parser</span><span class="Punctuation">,</span> <span class="Identifier">raiseOnFail</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span></pre></p>
<p>Run the GLR (Generalized LR) parser with advanced error recovery. Usually, we don't use this function directly, instead we use <tt class="docutils literal"><span class="pre">parse&lt;GrammarName&gt;</span></tt>, and <tt class="docutils literal"><span class="pre">proc newParser(source: string): Parser</span></tt>. <tt class="docutils literal"><span class="pre">runGenericGLR</span></tt> can be used for lower level control.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">parser</span></tt>: The parser instance (with lexer initialized)</li>
<li><tt class="docutils literal"><span class="pre">raiseOnFail</span></tt>: If <tt class="docutils literal"><span class="pre">true</span></tt>, raise exception on parse failure; if <tt class="docutils literal"><span class="pre">false</span></tt>, attempt error recovery (default: <tt class="docutils literal"><span class="pre">false</span></tt>)</li>
</ul>
<p><strong>Returns:</strong> The root <tt class="docutils literal"><span class="pre">ParseNode</span></tt> of the parse tree, or <tt class="docutils literal"><span class="pre">nil</span></tt> if parsing fails</p>
<p><strong>Error Recovery Strategies:</strong></p>
<ol class="simple"><li><strong>Stack Unwinding (Context Recovery)</strong><ul class="simple"><li>When encountering invalid tokens, tries to &quot;break out&quot; of current context</li>
<li>Unwinds parse stack to find ancestor state that can handle the token</li>
<li>Wraps dropped nodes in an <tt class="docutils literal"><span class="pre">ERROR</span></tt> node</li>
<li>Rewinds lexer to last &quot;recovery point&quot; (state 0) and tries minimal token skipping</li>
</ul>
</li>
<li><strong>Token Skipping (Fallback)</strong><ul class="simple"><li>If unwinding fails, skips the problematic token</li>
<li>Creates an <tt class="docutils literal"><span class="pre">ERROR</span></tt> node containing the skipped token</li>
<li>Continues parsing from the same state</li>
</ul>
</li>
<li><strong>EOF Handling</strong><ul class="simple"><li>If EOF is reached and can't be processed, forces accept with best available tree</li>
</ul>
</li>
</ol>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">var</span> <span class="Identifier">parser</span> <span class="Operator">=</span> <span class="Identifier">createParser</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">lexer</span><span class="Operator">.</span><span class="Identifier">setup</span><span class="Punctuation">(</span><span class="Identifier">sourceCode</span><span class="Punctuation">)</span>

<span class="Comment"># With error recovery (default)</span>
<span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">runGenericGLR</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">hasError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Warning: Parse tree contains errors&quot;</span>

<span class="Comment"># Strict mode (raise on error)</span>
<span class="Keyword">try</span><span class="Punctuation">:</span>
  <span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">runGenericGLR</span><span class="Punctuation">(</span><span class="Identifier">raiseOnFail</span> <span class="Operator">=</span> <span class="Identifier">true</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Parsed successfully&quot;</span>
<span class="Keyword">except</span> <span class="Identifier">ValueError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Parse failed&quot;</span></pre></p>
<p>---</p>

<h2 id="convenience-api">Convenience API</h2>
<h3 id="node-properties">Node Properties</h3>
<h4 id="kind"><tt class="docutils literal"><span class="pre">kind</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">kind</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>Get the node kind (symbol name) as a string.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Identifier">assert</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">kind</span> <span class="Operator">==</span> <span class="StringLit">&quot;expression&quot;</span></pre></p>

<h4 id="text"><tt class="docutils literal"><span class="pre">text</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">text</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>Get the text content of the node.</p>
<ul class="simple"><li><strong>Terminal nodes</strong>: Returns the token text</li>
<li><strong>Non-terminal nodes</strong>: Recursively concatenates text of all children</li>
</ul>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">expr</span> <span class="Operator">=</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;expression&quot;</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">expr</span><span class="Operator">.</span><span class="Identifier">text</span>  <span class="Comment"># &quot;x + 42&quot;</span></pre></p>

<h4 id="capture"><tt class="docutils literal"><span class="pre">capture</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">capture</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>
<p>Syntactic sugar for <tt class="docutils literal"><span class="pre">text(node)</span></tt>. Useful for query-like syntax.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">name</span> <span class="Operator">=</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;identifier&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">capture</span></pre></p>

<h3 id="child-access">Child Access</h3>
<h4 id="child-by-index"><tt class="docutils literal"><span class="pre">child</span></tt> (by index)</h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">child</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">index</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span></pre></p>
<p>Get child at index, returning <tt class="docutils literal"><span class="pre">nil</span></tt> if out of bounds.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">firstChild</span> <span class="Operator">=</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">secondChild</span> <span class="Operator">=</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre></p>

<h4 id="child-by-name"><tt class="docutils literal"><span class="pre">child</span></tt> (by name)</h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">child</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span></pre></p>
<p>Find <strong>first</strong> child with the given symbol name.</p>
<p><strong>Returns:</strong> The first matching child, or <tt class="docutils literal"><span class="pre">nil</span></tt> if not found</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">funcBody</span> <span class="Operator">=</span> <span class="Identifier">funcDef</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;block&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">funcName</span> <span class="Operator">=</span> <span class="Identifier">funcDef</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;identifier&quot;</span><span class="Punctuation">)</span></pre></p>

<h4 id="childcount"><tt class="docutils literal"><span class="pre">childCount</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">childCount</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>Get total number of children.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Node has &quot;</span><span class="Punctuation">,</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">childCount</span><span class="Punctuation">,</span> <span class="StringLit">&quot; children&quot;</span></pre></p>

<h3 id="named-children">Named Children</h3><p>Named children are nodes marked as &quot;named&quot; in the grammar (see <a class="reference external" href="#isnamed">`isNamed`</a>). This filters out anonymous tokens like punctuation.</p>

<h4 id="namedchildren-iterator"><tt class="docutils literal"><span class="pre">namedChildren</span></tt> (iterator)</h4><p><pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">namedChildren</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span></pre></p>
<p>Iterate over named children only.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">child</span> <span class="Keyword">in</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">namedChildren</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">child</span><span class="Operator">.</span><span class="Identifier">kind</span></pre></p>

<h4 id="namedchild"><tt class="docutils literal"><span class="pre">namedChild</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">namedChild</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">index</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span></pre></p>
<p>Get named child at index (skipping unnamed nodes).</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">firstArg</span> <span class="Operator">=</span> <span class="Identifier">funcCall</span><span class="Operator">.</span><span class="Identifier">namedChild</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">secondArg</span> <span class="Operator">=</span> <span class="Identifier">funcCall</span><span class="Operator">.</span><span class="Identifier">namedChild</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre></p>

<h4 id="namedchildcount"><tt class="docutils literal"><span class="pre">namedChildCount</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">namedChildCount</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre></p>
<p>Get number of named children.</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="StringLit">&quot;Function has &quot;</span><span class="Punctuation">,</span> <span class="Identifier">funcCall</span><span class="Operator">.</span><span class="Identifier">namedChildCount</span><span class="Punctuation">,</span> <span class="StringLit">&quot; arguments&quot;</span></pre></p>

<h3 id="error-detection">Error Detection</h3>
<h4 id="haserror"><tt class="docutils literal"><span class="pre">hasError</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">hasError</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span></pre></p>
<p>Check if the node or any descendant is an error node.</p>
<p><strong>Returns:</strong> <tt class="docutils literal"><span class="pre">true</span></tt> if any node in the subtree has kind <tt class="docutils literal"><span class="pre">&quot;ERROR&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;MISSING&quot;</span></tt></p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">parse</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">hasError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Parse tree contains errors&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Clean parse&quot;</span></pre></p>

<h3 id="incremental-parsing">Incremental Parsing</h3>
<h4 id="edit"><tt class="docutils literal"><span class="pre">edit</span></tt></h4><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">edit</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">,</span> <span class="Identifier">edit</span><span class="Punctuation">:</span> <span class="Identifier">InputEdit</span><span class="Punctuation">)</span></pre></p>
<p>Update node positions to reflect a source code edit. Used for incremental re-parsing.</p>
<p><strong>Parameters:</strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">node</span></tt>: Root node to update</li>
<li><tt class="docutils literal"><span class="pre">edit</span></tt>: Edit descriptor containing:<ul class="simple"><li><tt class="docutils literal"><span class="pre">startByte</span></tt>: Edit start position</li>
<li><tt class="docutils literal"><span class="pre">oldEndByte</span></tt>: Old length</li>
<li><tt class="docutils literal"><span class="pre">newEndByte</span></tt>: New length</li>
<li><tt class="docutils literal"><span class="pre">oldEndPoint</span></tt>: Old end (row, column)</li>
<li><tt class="docutils literal"><span class="pre">newEndPoint</span></tt>: New end (row, column)</li>
</ul>
</li>
</ul>
<p><strong>Behavior:</strong></p>
<ul class="simple"><li>Nodes <strong>after</strong> the edit: shifted by delta</li>
<li>Nodes <strong>overlapping</strong> the edit: end positions updated</li>
<li>Updates both byte positions and <tt class="docutils literal"><span class="pre">Point</span></tt> (row/column) coordinates</li>
</ul>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Comment"># User inserted 5 characters at position 10</span>
<span class="Keyword">let</span> <span class="Identifier">edit</span> <span class="Operator">=</span> <span class="Identifier">InputEdit</span><span class="Punctuation">(</span>
  <span class="Identifier">startByte</span><span class="Punctuation">:</span> <span class="DecNumber">10</span><span class="Punctuation">,</span>
  <span class="Identifier">oldEndByte</span><span class="Punctuation">:</span> <span class="DecNumber">0</span><span class="Punctuation">,</span>
  <span class="Identifier">newEndByte</span><span class="Punctuation">:</span> <span class="DecNumber">5</span><span class="Punctuation">,</span>
  <span class="Identifier">oldEndPoint</span><span class="Punctuation">:</span> <span class="Identifier">Point</span><span class="Punctuation">(</span><span class="Identifier">row</span><span class="Punctuation">:</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">column</span><span class="Punctuation">:</span> <span class="DecNumber">10</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
  <span class="Identifier">newEndPoint</span><span class="Punctuation">:</span> <span class="Identifier">Point</span><span class="Punctuation">(</span><span class="Identifier">row</span><span class="Punctuation">:</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">column</span><span class="Punctuation">:</span> <span class="DecNumber">15</span><span class="Punctuation">)</span>
<span class="Punctuation">)</span>
<span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">edit</span><span class="Punctuation">(</span><span class="Identifier">edit</span><span class="Punctuation">)</span>
<span class="Comment"># Now tree positions reflect the edit</span></pre></p>
<p>---</p>

<h2 id="corpus-generation">Corpus Generation</h2>
<h3 id="writecorpus"><tt class="docutils literal"><span class="pre">writeCorpus</span></tt></h3><p><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">writeCorpus</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">filename</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">testName</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">input</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">,</span>
                  <span class="Identifier">tree</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span> <span class="Operator">=</span> <span class="Keyword">nil</span><span class="Punctuation">,</span> <span class="Identifier">expectedSExpr</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span></pre></p>
<p>Write or append a test case to a corpus file (tree-sitter corpus format).</p>
<p><strong>Parameters:</strong></p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">filename</span></tt>: Corpus file path</li>
<li><tt class="docutils literal"><span class="pre">testName</span></tt>: Name of the test case</li>
<li><tt class="docutils literal"><span class="pre">input</span></tt>: Input source code</li>
<li><tt class="docutils literal"><span class="pre">tree</span></tt>: Optional parse tree (will be converted to S-expression)</li>
<li><tt class="docutils literal"><span class="pre">expectedSExpr</span></tt>: Optional expected output (overrides <tt class="docutils literal"><span class="pre">tree</span></tt>)</li>
</ul>
<p><strong>Corpus Format:</strong></p>
<p><pre class="listing">==================
Test Name
==================
input source code
---
(expected
  (s-expression))</pre></p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Comment"># Using parsed tree</span>
<span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">parse</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Identifier">writeCorpus</span><span class="Punctuation">(</span><span class="StringLit">&quot;tests/corpus.txt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;simple addition&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;1 + 2&quot;</span><span class="Punctuation">,</span> <span class="Identifier">tree</span><span class="Punctuation">)</span>

<span class="Comment"># Using explicit expected output</span>
<span class="Identifier">writeCorpus</span><span class="Punctuation">(</span>
  <span class="StringLit">&quot;tests/corpus.txt&quot;</span><span class="Punctuation">,</span>
  <span class="StringLit">&quot;error test&quot;</span><span class="Punctuation">,</span>
  <span class="StringLit">&quot;invalid syntax&quot;</span><span class="Punctuation">,</span>
  <span class="Identifier">expectedSExpr</span> <span class="Operator">=</span> <span class="StringLit">&quot;(program (ERROR))&quot;</span>
<span class="Punctuation">)</span></pre></p>
<p>---</p>

<h2 id="iterator-api">Iterator API</h2>
<h3 id="children"><tt class="docutils literal"><span class="pre">children</span></tt></h3><p><pre class="listing"><span class="Keyword">iterator</span> <span class="Identifier">children</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">ParseNode</span></pre></p>
<p>Iterate over <strong>all</strong> children (named and unnamed).</p>
<p><strong>Example:</strong></p>
<p><pre class="listing"><span class="Keyword">for</span> <span class="Identifier">child</span> <span class="Keyword">in</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">children</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">child</span><span class="Operator">.</span><span class="Identifier">kind</span></pre></p>
<p>See also: <a class="reference external" href="#namedchildren-iterator">`namedChildren`</a> for named-only iteration.</p>
<p>---</p>

<h2 id="complete-example">Complete Example</h2><p><pre class="listing"><span class="Comment"># Generated parser includes parser_runtime automatically</span>
<span class="Keyword">import</span> <span class="Identifier">parser</span> <span class="Comment"># assume grammar name is Document</span>

<span class="Keyword">let</span> <span class="Identifier">source</span> <span class="Operator">=</span> <span class="LongStringLit">&quot;&quot;&quot;
function add(x, y) {
  return x + y;
}
&quot;&quot;&quot;</span>

<span class="Keyword">let</span> <span class="Identifier">tree</span> <span class="Operator">=</span> <span class="Identifier">parseDocument</span><span class="Punctuation">(</span><span class="Identifier">source</span><span class="Punctuation">)</span>

<span class="Comment"># Check for errors</span>
<span class="Keyword">if</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">hasError</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Parse tree contains errors&quot;</span>
  <span class="Identifier">echo</span> <span class="Identifier">toSExpr</span><span class="Punctuation">(</span><span class="Identifier">tree</span><span class="Punctuation">)</span>  <span class="Comment"># Show where errors occurred</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Comment"># Traverse named children only</span>
  <span class="Keyword">for</span> <span class="Identifier">funcDef</span> <span class="Keyword">in</span> <span class="Identifier">tree</span><span class="Operator">.</span><span class="Identifier">findNodesBySymbol</span><span class="Punctuation">(</span><span class="StringLit">&quot;function_definition&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">funcName</span> <span class="Operator">=</span> <span class="Identifier">funcDef</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;identifier&quot;</span><span class="Punctuation">)</span>
    <span class="Keyword">let</span> <span class="Identifier">params</span> <span class="Operator">=</span> <span class="Identifier">funcDef</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;parameters&quot;</span><span class="Punctuation">)</span>
    
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Function: &quot;</span><span class="Punctuation">,</span> <span class="Identifier">funcName</span><span class="Operator">.</span><span class="Identifier">text</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;  Parameters:&quot;</span>
    <span class="Keyword">for</span> <span class="Identifier">param</span> <span class="Keyword">in</span> <span class="Identifier">params</span><span class="Operator">.</span><span class="Identifier">namedChildren</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;    - &quot;</span><span class="Punctuation">,</span> <span class="Identifier">param</span><span class="Operator">.</span><span class="Identifier">text</span>

<span class="Comment"># Write to corpus for regression testing</span>
<span class="Identifier">writeCorpus</span><span class="Punctuation">(</span><span class="StringLit">&quot;tests/corpus.txt&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;function definition&quot;</span><span class="Punctuation">,</span> <span class="Identifier">source</span><span class="Punctuation">,</span> <span class="Identifier">tree</span><span class="Punctuation">)</span></pre></p>
<p>---</p>

<h2 id="see-also">See Also</h2><ul class="simple"><li><a class="reference external" href="using_dsl.md">Grammar DSL Documentation</a> - Define grammars</li>
<li><a class="reference external" href="../examples/">Examples</a> - Working examples</li>
<li><a class="reference external" href="parser_types.nim">Parser Types</a> - Core data structures (<tt class="docutils literal"><span class="pre">ParseNode</span></tt>, <tt class="docutils literal"><span class="pre">Symbol</span></tt>, <tt class="docutils literal"><span class="pre">Token</span></tt>, etc.)</li>
</ul>



      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2026-01-09 00:05:54 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
