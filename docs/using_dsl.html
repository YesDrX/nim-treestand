<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en" data-theme="auto">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>docs/using_dsl</title>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css?v=2.2.4">

<!-- JS -->
<script type="text/javascript" src="dochack.js?v=2.2.4"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">docs/using_dsl</h1>
      
<h1 id="using-the-treestand-dsl">Using the Treestand DSL</h1><p>Treestand provides a powerful Domain Specific Language (DSL) in Nim to define grammars programmatically. This approach gives you full power of the host language (macros, loops, variables) to construct complex grammars.</p>

<h2 id="introduction">Introduction</h2><p>Treestand offers two ways to define grammars:</p>
<ol class="simple"><li><strong>Macro DSL (`tsGrammar`)</strong>: A concise, operator-based syntax inspired by PEG/npeg. (Recommended)</li>
<li><strong>Procedural DSL</strong>: A set of helper functions (<tt class="docutils literal"><span class="pre">seq</span></tt>, <tt class="docutils literal"><span class="pre">choice</span></tt>, <tt class="docutils literal"><span class="pre">rep</span></tt>, etc.) used to build <tt class="docutils literal"><span class="pre">InputGrammar</span></tt> objects manually.</li>
</ol>
<p>This guide covers both, starting with the recommended macro DSL.</p>

<h2 id="macro-dsl-tsgrammar">Macro DSL (<tt class="docutils literal"><span class="pre">tsGrammar</span></tt>)</h2><p>The <tt class="docutils literal"><span class="pre">tsGrammar</span></tt> macro allows you to define grammars using a clean, readable syntax.</p>

<h3 id="basic-syntax">Basic Syntax</h3><p><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">treestand</span>

<span class="Identifier">tsGrammar</span> <span class="StringLit">&quot;my_lang&quot;</span><span class="Punctuation">:</span>
  <span class="Comment"># Rule Assignment</span>
  <span class="Identifier">program</span>     <span class="Operator">&lt;-</span> <span class="Operator">+</span><span class="Identifier">stmt</span>
  
  <span class="Comment"># Sequence (*) and Choice (|)</span>
  <span class="Identifier">stmt</span>        <span class="Operator">&lt;-</span> <span class="Identifier">assign</span> <span class="Operator">*</span> <span class="Identifier">semi</span>
  
  <span class="Comment"># Repetition</span>
  <span class="Comment"># +rule  -&gt; One or more</span>
  <span class="Comment"># *rule  -&gt; Zero or more</span>
  <span class="Comment"># ?rule  -&gt; Optional</span>
  <span class="Identifier">assign</span>      <span class="Operator">&lt;-</span> <span class="Punctuation">(</span><span class="Identifier">variable</span><span class="Punctuation">:</span> <span class="Identifier">identifier</span><span class="Punctuation">)</span> <span class="Operator">*</span> <span class="Identifier">eq</span> <span class="Operator">*</span> <span class="Punctuation">(</span><span class="Identifier">value</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Comment"># Named fields by (fld : rule) format</span>
  <span class="Identifier">expr</span>        <span class="Operator">&lt;-</span> <span class="Identifier">identifier</span> <span class="Operator">|</span> <span class="Identifier">number</span> <span class="Operator">|</span> <span class="Identifier">external_token</span> <span class="Comment"># external_token is a token handled by an external scanner (C function), but not implemented in tsGrammar yet</span>
  
  <span class="Comment"># Lexical Tokens</span>
  <span class="Comment"># Use token() wrapper for lexical rules</span>
  <span class="Comment"># String literals and regex patterns are auto-wrapped with str() or patt()</span>
  <span class="Identifier">identifier</span>  <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="RawData">re&quot;\w+&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">number</span>      <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="RawData">re&quot;\\d+&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">eq</span>          <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="StringLit">&quot;=&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">semi</span>        <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="StringLit">&quot;;&quot;</span><span class="Punctuation">)</span>
  
  <span class="Comment"># ConfigurationÂ·</span>
  <span class="Identifier">extras</span>      <span class="Operator">=</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="RawData">re&quot;\s+&quot;</span><span class="Punctuation">)</span>
  <span class="Comment"># word        = &quot;identifier&quot;</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">parseMyLang</span><span class="Punctuation">(</span><span class="StringLit">&quot;a = 1; b=a;&quot;</span><span class="Punctuation">)</span></pre></p>

<h3 id="operators-amp-mapping">Operators &amp; Mapping</h3><p>The macro translates operators into procedural DSL calls:</p>
<table border="1" class="docutils"><tr><th>Operator</th><th>Syntax</th><th>Equivalent Function</th><th>Description</th></tr>
<tr><td><strong>Assignment</strong></td><td><tt class="docutils literal"><span class="pre">name &lt;- rule</span></tt></td><td><tt class="docutils literal"><span class="pre">Variable(name, ...)</span></tt></td><td>Defines a rule.</td></tr>
<tr><td><strong>Sequence</strong></td><td><tt class="docutils literal"><span class="pre">a * b</span></tt></td><td><tt class="docutils literal"><span class="pre">seq(a, b)</span></tt></td><td>Matches <tt class="docutils literal"><span class="pre">a</span></tt> then <tt class="docutils literal"><span class="pre">b</span></tt>.</td></tr>
<tr><td><strong>Choice</strong></td><td><tt class="docutils literal"><span class="pre">a \| b</span></tt></td><td><tt class="docutils literal"><span class="pre">choice(a, b)</span></tt></td><td>Matches <tt class="docutils literal"><span class="pre">a</span></tt> OR <tt class="docutils literal"><span class="pre">b</span></tt>.</td></tr>
<tr><td><strong>One-or-More</strong></td><td><tt class="docutils literal"><span class="pre">+a</span></tt></td><td><tt class="docutils literal"><span class="pre">rep(a)</span></tt></td><td>Matches <tt class="docutils literal"><span class="pre">a</span></tt> at least once.</td></tr>
<tr><td><strong>Zero-or-More</strong></td><td><tt class="docutils literal"><span class="pre">*a</span></tt></td><td><tt class="docutils literal"><span class="pre">opt(rep(a))</span></tt></td><td>Matches <tt class="docutils literal"><span class="pre">a</span></tt> zero or more times.</td></tr>
<tr><td><strong>Optional</strong></td><td><tt class="docutils literal"><span class="pre">?a</span></tt></td><td><tt class="docutils literal"><span class="pre">opt(a)</span></tt></td><td>Matches <tt class="docutils literal"><span class="pre">a</span></tt> zero or one time.</td></tr>
<tr><td><strong>Precedence</strong></td><td><tt class="docutils literal"><span class="pre">rule ^ N</span></tt></td><td><tt class="docutils literal"><span class="pre">prec_left(N, rule)</span></tt></td><td>Sets precedence level <tt class="docutils literal"><span class="pre">N</span></tt>.</td></tr>
<tr><td><strong>Named Field</strong></td><td><tt class="docutils literal"><span class="pre">(name: rule)</span></tt></td><td><tt class="docutils literal"><span class="pre">field(&quot;name&quot;, rule)</span></tt></td><td>Assigns a field name to the node.</td></tr>
<tr><td><strong>Set/Keywords</strong></td><td><tt class="docutils literal"><span class="pre">{&quot;a&quot;, &quot;b&quot;}</span></tt></td><td><tt class="docutils literal"><span class="pre">choice(str(&quot;a&quot;), str(&quot;b&quot;))</span></tt></td><td>Matches one of the string literals.</td></tr>
</table>
<h3 id="configuration-properties">Configuration Properties</h3><p>You can set <tt class="docutils literal"><span class="pre">InputGrammar</span></tt> properties using <tt class="docutils literal"><span class="pre">field = value</span></tt> syntax within the macro block:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">extras = rule</span></tt>: Define tokens to skip (e.g., whitespace).</li>
<li><tt class="docutils literal"><span class="pre">conflicts = @[...]</span></tt>: Document expected conflicts.</li>
<li><tt class="docutils literal"><span class="pre">inline = @[&quot;rule&quot;]</span></tt>: Rules to inline.</li>
<li><tt class="docutils literal"><span class="pre">supertypes = @[&quot;rule&quot;]</span></tt>: Rules to treat as supertypes.</li>
<li><tt class="docutils literal"><span class="pre">word = &quot;token_name&quot;</span></tt>: Token to use for keyword extraction optimization.</li>
<li><tt class="docutils literal"><span class="pre">scanner = &quot;path&quot;</span></tt>: Placeholder for external scanner path (handled by CLI usually).</li>
</ul>

<h3 id="external-tokens">External Tokens</h3><p>To define a token handled by an external scanner (C function):</p>
<p><pre class="listing"><span class="Identifier">indent</span> <span class="Operator">&lt;-</span> <span class="Identifier">external_token</span></pre></p>

<h3 id="embedded-actions">Embedded Actions</h3><p>The <tt class="docutils literal"><span class="pre">tsGrammar</span></tt> macro supports <strong>embedded actions</strong> - Nim code blocks that execute during parsing to build custom data structures, validate semantics, or perform side effects.</p>

<h4 id="basic-syntax">Basic Syntax</h4><p><pre class="listing"><span class="Keyword">type</span> <span class="Identifier">UserData</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">vars</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>

<span class="Identifier">tsGrammar</span> <span class="StringLit">&quot;calc&quot;</span><span class="Punctuation">,</span> <span class="Identifier">userdata</span><span class="Punctuation">:</span> <span class="Identifier">UserData</span><span class="Punctuation">:</span>
  <span class="Identifier">assign</span> <span class="Operator">&lt;-</span> <span class="Identifier">ident</span> <span class="Operator">*</span> <span class="Identifier">eq</span> <span class="Operator">*</span> <span class="Identifier">number</span> <span class="Operator">*</span> <span class="Identifier">semi</span><span class="Punctuation">:</span>
    <span class="Comment"># Action code runs when this rule matches</span>
    <span class="Identifier">echo</span> <span class="StringLit">&quot;Found assignment!&quot;</span></pre></p>

<h4 id="available-symbols">Available Symbols</h4><p>Within action blocks, you have access to:</p>
<ul class="simple"><li><strong>`node: ParseNode`</strong> - The matched parse node for this rule</li>
<li><strong>`userdata: var YourType`</strong> - Mutable userdata object</li>
<li><strong>`input: string`</strong> - The original input string</li>
</ul>

<h4 id="node-api">Node API</h4><p><pre class="listing"><span class="Comment"># Access children</span>
<span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">children</span>         <span class="Comment"># seq[ParseNode] - all children</span>
<span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="DecNumber">0</span><span class="Punctuation">)</span>         <span class="Comment"># Get child by index (0-based)</span>
<span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;ident&quot;</span><span class="Punctuation">)</span>   <span class="Comment"># Get first child with symbol name</span>
<span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">childCount</span><span class="Punctuation">(</span><span class="Punctuation">)</span>     <span class="Comment"># Number of children</span>

<span class="Comment"># Get text content</span>
<span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">text</span>             <span class="Comment"># Text content of node</span>
<span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">kind</span>             <span class="Comment"># Symbol name as string</span></pre></p>

<h4 id="examplecolon-symbol-table">Example: Symbol Table</h4><p><pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Env</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">vars</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>

<span class="Identifier">tsGrammar</span> <span class="StringLit">&quot;calc&quot;</span><span class="Punctuation">,</span> <span class="Identifier">userdata</span><span class="Punctuation">:</span> <span class="Identifier">Env</span><span class="Punctuation">:</span>
  <span class="Identifier">assign</span> <span class="Operator">&lt;-</span> <span class="Identifier">ident</span> <span class="Operator">*</span> <span class="Identifier">eq</span> <span class="Operator">*</span> <span class="Identifier">number</span> <span class="Operator">*</span> <span class="Identifier">semi</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">varName</span> <span class="Operator">=</span> <span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;ident&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">text</span>
    <span class="Keyword">let</span> <span class="Identifier">value</span> <span class="Operator">=</span> <span class="Identifier">parseInt</span><span class="Punctuation">(</span><span class="Identifier">node</span><span class="Operator">.</span><span class="Identifier">child</span><span class="Punctuation">(</span><span class="StringLit">&quot;number&quot;</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">text</span><span class="Punctuation">)</span>
    <span class="Identifier">userdata</span><span class="Operator">.</span><span class="Identifier">vars</span><span class="Punctuation">[</span><span class="Identifier">varName</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">value</span>
  
  <span class="Identifier">ident</span>  <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="RawData">re&quot;[a-zA-Z_]\\w*&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">number</span> <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="RawData">re&quot;\\d+&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">eq</span>     <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="StringLit">&quot;=&quot;</span><span class="Punctuation">)</span>
  <span class="Identifier">semi</span>   <span class="Operator">&lt;-</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="StringLit">&quot;;&quot;</span><span class="Punctuation">)</span>

<span class="Comment"># Usage</span>
<span class="Keyword">var</span> <span class="Identifier">env</span> <span class="Operator">=</span> <span class="Identifier">Env</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Identifier">matchCalc</span><span class="Punctuation">(</span><span class="StringLit">&quot;x = 10;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">env</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">env</span><span class="Operator">.</span><span class="Identifier">vars</span>  <span class="Comment"># {&quot;x&quot;: 10}</span></pre></p>
<p>See <a class="reference external" href="../examples/09_ast_actions">`examples/09_ast_actions`</a> for a complete AST construction example.</p>

<h4 id="action-execution-order">Action Execution Order</h4><p>Actions execute in <strong>post-order</strong> (bottom-up):</p>
<ol class="simple"><li>Child nodes are visited first</li>
<li>Then parent node's action runs</li>
</ol>
<p>This ensures child data is available when processing parents.</p>

<h2 id="procedural-dsl-lowminuslevel">Procedural DSL (Low-Level)</h2><p>The procedural DSL involves manually constructing <tt class="docutils literal"><span class="pre">InputGrammar</span></tt> objects using helper functions. This is useful for programmatic generation or dynamic grammars.</p>

<h3 id="core-dsl-functions">Core DSL Functions</h3><p>Import <tt class="docutils literal"><span class="pre">treestand/dsl</span></tt> to access these helpers.</p>

<h3 id="basic-rules">Basic Rules</h3><table border="1" class="docutils"><tr><th>Function</th><th>Description</th><th>Example</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">str(&quot;s&quot;)</span></tt></td><td>Literal string match.</td><td><tt class="docutils literal"><span class="pre">str(&quot;class&quot;)</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">patt(&quot;r&quot;)</span></tt></td><td>Regex pattern.</td><td><tt class="docutils literal"><span class="pre">patt(&quot;[a-zA-Z_]\w*&quot;)</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">sym(&quot;name&quot;)</span></tt></td><td>Reference to another rule.</td><td><tt class="docutils literal"><span class="pre">sym(&quot;statement&quot;)</span></tt></td></tr>
</table>
<h3 id="combinators">Combinators</h3><table border="1" class="docutils"><tr><th>Function</th><th>Description</th><th>Example</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">seq(...)</span></tt></td><td>Sequence (concatenation).</td><td><tt class="docutils literal"><span class="pre">seq(str(&quot;if&quot;), sym(&quot;expr&quot;), str(&quot;:&quot;))</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">choice(...)</span></tt></td><td>Ordered choice (alternatives).</td><td><tt class="docutils literal"><span class="pre">choice(sym(&quot;if_stmt&quot;), sym(&quot;while_stmt&quot;))</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">rep(rule)</span></tt></td><td>Repetition (one or more).</td><td><tt class="docutils literal"><span class="pre">rep(sym(&quot;item&quot;))</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">opt(rule)</span></tt></td><td>Optional (zero or one).</td><td><tt class="docutils literal"><span class="pre">opt(str(&quot;pub&quot;))</span></tt></td></tr>
</table>
<h3 id="metadata-amp-tokens">Metadata &amp; Tokens</h3><table border="1" class="docutils"><tr><th>Function</th><th>Description</th><th>Example</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">token(rule)</span></tt></td><td>Mark rule as a lexical token. This collapses the internal structure into a single leaf node.</td><td><tt class="docutils literal"><span class="pre">token(seq(patt(&quot;\d+&quot;), opt(str(&quot;.&quot;))))</span></tt></td></tr>
</table>
<h3 id="precedence-amp-associativity">Precedence &amp; Associativity</h3><p>Handling ambiguity is crucial for parsers.</p>
<table border="1" class="docutils"><tr><th>Function</th><th>Description</th><th>Example</th></tr>
<tr><td><tt class="docutils literal"><span class="pre">prec(n, rule)</span></tt></td><td>Static precedence level <tt class="docutils literal"><span class="pre">n</span></tt>.</td><td><tt class="docutils literal"><span class="pre">prec(2, sym(&quot;mult_op&quot;))</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">prec_left(n, rule)</span></tt></td><td>Left associativity.</td><td><tt class="docutils literal"><span class="pre">1 + 2 + 3</span></tt> -&gt; <tt class="docutils literal"><span class="pre">(1 + 2) + 3</span></tt></td></tr>
<tr><td><tt class="docutils literal"><span class="pre">prec_right(n, rule)</span></tt></td><td>Right associativity.</td><td><tt class="docutils literal"><span class="pre">x = y = z</span></tt> -&gt; <tt class="docutils literal"><span class="pre">x = (y = z)</span></tt></td></tr>
</table>
<h2 id="create-a-grammar-using-dsl">Create a Grammar using DSL</h2><p><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">treestand</span>

<span class="Keyword">proc</span> <span class="Identifier">createMathGrammar</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">InputGrammar</span> <span class="Operator">=</span>
  <span class="Comment">## Defines a simple mathematical expression grammar.</span>
  <span class="Comment">## This grammar supports basic arithmetic operations (+, -, *, /) on integers.</span>
  <span class="Identifier">InputGrammar</span><span class="Punctuation">(</span>
    <span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;math&quot;</span><span class="Punctuation">,</span>
    <span class="Identifier">variables</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Punctuation">[</span>
      <span class="Comment"># 'program' is the start rule. It consists of one or more expressions.</span>
      <span class="Comment"># `rep` is a DSL helper for repetition (one or more).</span>
      <span class="Comment"># `sym` refers to another rule by name.</span>
      <span class="Identifier">Variable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;program&quot;</span><span class="Punctuation">,</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">vtNamed</span><span class="Punctuation">,</span> <span class="Identifier">rule</span><span class="Punctuation">:</span> <span class="Identifier">rep</span><span class="Punctuation">(</span><span class="Identifier">sym</span><span class="Punctuation">(</span><span class="StringLit">&quot;expression&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
      
      <span class="Comment"># 'expression' can be either a number or a binary operation.</span>
      <span class="Comment"># `choice` represents alternatives (OR).</span>
      <span class="Identifier">Variable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;expression&quot;</span><span class="Punctuation">,</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">vtNamed</span><span class="Punctuation">,</span> <span class="Identifier">rule</span><span class="Punctuation">:</span> <span class="Identifier">choice</span><span class="Punctuation">(</span><span class="Identifier">sym</span><span class="Punctuation">(</span><span class="StringLit">&quot;number&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">sym</span><span class="Punctuation">(</span><span class="StringLit">&quot;binary_op&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
      
      <span class="Comment"># 'binary_op' defines the structure of an operation: expression &lt;op&gt; expression.</span>
      <span class="Comment"># `prec_left(1, ...)` specifies left associativity with precedence level 1.</span>
      <span class="Comment"># This ensures operations like 1 + 2 + 3 are parsed as (1 + 2) + 3.</span>
      <span class="Comment"># `seq` represents a sequence of elements.</span>
      <span class="Identifier">Variable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;binary_op&quot;</span><span class="Punctuation">,</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">vtNamed</span><span class="Punctuation">,</span> <span class="Identifier">rule</span><span class="Punctuation">:</span> <span class="Identifier">prec_left</span><span class="Punctuation">(</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="Identifier">seq</span><span class="Punctuation">(</span><span class="Identifier">sym</span><span class="Punctuation">(</span><span class="StringLit">&quot;expression&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">sym</span><span class="Punctuation">(</span><span class="StringLit">&quot;op&quot;</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">sym</span><span class="Punctuation">(</span><span class="StringLit">&quot;expression&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
      
      <span class="Comment"># 'number' is a lexical token matching digits.</span>
      <span class="Comment"># `token` marks this rule as a lexical unit (handled by the lexer).</span>
      <span class="Comment"># `patt` creates a regex pattern.</span>
      <span class="Identifier">Variable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;number&quot;</span><span class="Punctuation">,</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">vtNamed</span><span class="Punctuation">,</span> <span class="Identifier">rule</span><span class="Punctuation">:</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="Identifier">patt</span><span class="Punctuation">(</span><span class="StringLit">&quot;</span><span class="EscapeSequence">\\</span><span class="StringLit">d+&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">,</span>
      
      <span class="Comment"># 'op' is a lexical token matching operator characters.</span>
      <span class="Identifier">Variable</span><span class="Punctuation">(</span><span class="Identifier">name</span><span class="Punctuation">:</span> <span class="StringLit">&quot;op&quot;</span><span class="Punctuation">,</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">vtNamed</span><span class="Punctuation">,</span> <span class="Identifier">rule</span><span class="Punctuation">:</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="Identifier">patt</span><span class="Punctuation">(</span><span class="StringLit">&quot;[+</span><span class="EscapeSequence">\\</span><span class="StringLit">-*/]&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Punctuation">]</span><span class="Punctuation">,</span>
    
    <span class="Comment"># 'extraSymbols' are tokens that can appear anywhere between other tokens, usually whitespace or comments.</span>
    <span class="Comment"># They are automatically skipped by the parser but consumed by the lexer.</span>
    <span class="Identifier">extraSymbols</span><span class="Punctuation">:</span> <span class="Operator">@</span><span class="Punctuation">[</span> <span class="Identifier">token</span><span class="Punctuation">(</span><span class="Identifier">patt</span><span class="Punctuation">(</span><span class="StringLit">&quot;</span><span class="EscapeSequence">\\</span><span class="StringLit">s+&quot;</span><span class="Punctuation">)</span><span class="Punctuation">)</span> <span class="Punctuation">]</span>
  <span class="Punctuation">)</span>

<span class="Keyword">when</span> <span class="Identifier">isMainModule</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Generating parser for 'math' grammar...&quot;</span>
  <span class="Keyword">let</span> <span class="Identifier">g</span> <span class="Operator">=</span> <span class="Identifier">createMathGrammar</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
  
  <span class="Identifier">generateParser</span><span class="Punctuation">(</span><span class="Identifier">g</span><span class="Punctuation">,</span> <span class="StringLit">&quot;myparser.nim&quot;</span><span class="Punctuation">)</span>
  
  <span class="Identifier">echo</span> <span class="StringLit">&quot;Parser generated to myparser.nim&quot;</span></pre></p>

<h2 id="using-the-generated-parser">Using the generated Parser</h2><p>Once you have generated your <tt class="docutils literal"><span class="pre">myparser.nim</span></tt> (see Getting Started), you can interact with it.</p>

<h3 id="parsing">Parsing</h3><p><pre class="listing"><span class="Keyword">import</span> <span class="Identifier">myparser</span>

<span class="Keyword">var</span> <span class="Identifier">parser</span> <span class="Operator">=</span> <span class="Identifier">newParser</span><span class="Punctuation">(</span><span class="StringLit">&quot;source code&quot;</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">rootNode</span> <span class="Operator">=</span> <span class="Identifier">parser</span><span class="Operator">.</span><span class="Identifier">parse</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre></p>

<h3 id="traversing-the-tree">Traversing the Tree</h3><p>The <tt class="docutils literal"><span class="pre">ParseNode</span></tt> object provides runtime access to the tree.</p>
<p><pre class="listing"><span class="Identifier">echo</span> <span class="Identifier">kind</span><span class="Punctuation">(</span><span class="Identifier">rootNode</span><span class="Punctuation">)</span>   <span class="Comment"># e.g. &quot;program&quot;</span>
<span class="Identifier">echo</span> <span class="Identifier">rootNode</span><span class="Operator">.</span><span class="Identifier">startPos</span> <span class="Comment"># Byte offset</span>

<span class="Keyword">for</span> <span class="Identifier">child</span> <span class="Keyword">in</span> <span class="Identifier">children</span><span class="Punctuation">(</span><span class="Identifier">rootNode</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="Identifier">kind</span><span class="Punctuation">(</span><span class="Identifier">child</span><span class="Punctuation">)</span></pre></p>

<h3 id="editing-incremental-parsing">Editing (Incremental Parsing)</h3><p>Treestand supports basic tree editing APIs to prepare for incremental parsing support.</p>
<p><pre class="listing"><span class="Comment"># Example: Insert text into the source</span>
<span class="Comment"># Note: Full incremental reparsing is an advanced topic</span>
<span class="Keyword">let</span> <span class="Identifier">newSource</span> <span class="Operator">=</span> <span class="StringLit">&quot;1 + 2&quot;</span>
<span class="Comment"># ... edit logic ...</span></pre></p>

<h3 id="querying">Querying</h3><p>Treestand supports a Tree-sitter compatible query language (S-expressions) for pattern matching against the tree.</p>
<p><pre class="listing"><span class="Comment"># Conceptual usage</span>
<span class="Keyword">let</span> <span class="Identifier">query</span> <span class="Operator">=</span> <span class="LongStringLit">&quot;&quot;&quot;
(binary_op
  left: (number) @left
  operator: (op) @op
  right: (number) @right)
&quot;&quot;&quot;</span>
<span class="Comment"># match(rootNode, query) ...</span></pre> </p>



      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2025-12-26 18:34:17 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
