nimTitle	build_tables	treestand/build_tables.html	module src/treestand/build_tables		0
nim	BuildTablesError	treestand/build_tables.html#BuildTablesError	object BuildTablesError		10
nim	Tables	treestand/build_tables.html#Tables	object Tables		12
nim	TokenConflictStatus	treestand/build_tables.html#TokenConflictStatus	object TokenConflictStatus		30
nim	TokenConflictMap	treestand/build_tables.html#TokenConflictMap	object TokenConflictMap		38
nim	FirstSets	treestand/build_tables.html#FirstSets	type FirstSets		45
nim	FollowSets	treestand/build_tables.html#FollowSets	type FollowSets		46
nim	LookaheadSet	treestand/build_tables.html#LookaheadSet	type LookaheadSet		65
nim	LookaheadSetInfo	treestand/build_tables.html#LookaheadSetInfo	object LookaheadSetInfo		67
nim	ClosureAddition	treestand/build_tables.html#ClosureAddition	object ClosureAddition		72
nim	ClosureCache	treestand/build_tables.html#ClosureCache	object ClosureCache		79
nim	buildParseTable	treestand/build_tables.html#buildParseTable,SyntaxGrammar,LexicalGrammar	proc buildParseTable(grammar: SyntaxGrammar; lexicalGrammar: LexicalGrammar): BuildParseTable		92
nim	computeFirst	treestand/build_tables.html#computeFirst,SyntaxGrammar	proc computeFirst(grammar: SyntaxGrammar): FirstSets		95
nim	newTokenConflictMap	treestand/build_tables.html#newTokenConflictMap,LexicalGrammar,seq[HashSet[uint32]]	proc newTokenConflictMap(lexicalGrammar: LexicalGrammar;\n                    followingTokens: seq[HashSet[uint32]]): TokenConflictMap		103
nim	buildTables	treestand/build_tables.html#buildTables,SyntaxGrammar,LexicalGrammar	proc buildTables(syntaxGrammar: SyntaxGrammar; lexicalGrammar: LexicalGrammar): Tables		108
nim	computeNullability	treestand/build_tables.html#computeNullability,SyntaxGrammar	proc computeNullability(grammar: var SyntaxGrammar)		682
nim	doesConflict	treestand/build_tables.html#doesConflict,TokenConflictMap,int,int	proc doesConflict(map: TokenConflictMap; i, j: int): bool		1035
nim	doesMatchSameString	treestand/build_tables.html#doesMatchSameString,TokenConflictMap,int,int	proc doesMatchSameString(map: TokenConflictMap; i, j: int): bool		1039
nim	preferToken	treestand/build_tables.html#preferToken,LexicalGrammar,,	proc preferToken(grammar: LexicalGrammar; left: (int32, int); right: (int32, int)): bool		1042
nim	preferTransition	treestand/build_tables.html#preferTransition,LexicalGrammar,NfaTransition,int,int32,bool	proc preferTransition(grammar: LexicalGrammar; t: NfaTransition; completedId: int;\n                 completedPrecedence: int32; hasSeparatorTransitions: bool): bool		1058
nim	computeFollow	treestand/build_tables.html#computeFollow,SyntaxGrammar,FirstSets	proc computeFollow(grammar: SyntaxGrammar; firstSets: FirstSets): FollowSets		1272
nim	LR1Item	treestand/build_tables.html#LR1Item	object LR1Item		1337
nim	hash	treestand/build_tables.html#hash,LR1Item	proc hash(item: LR1Item): Hash		1344
nim	`==`	treestand/build_tables.html#==,LR1Item,LR1Item	proc `==`(a, b: LR1Item): bool		1353
nim	`<`	treestand/build_tables.html#<,LR1Item,LR1Item	proc `<`(a, b: LR1Item): bool		1360
nim	CoreItem	treestand/build_tables.html#CoreItem	object CoreItem		1371
nim	StateKernels	treestand/build_tables.html#StateKernels	type StateKernels		1379
nim	hash	treestand/build_tables.html#hash,CoreItem	proc hash(item: CoreItem): Hash		1383
nim	`==`	treestand/build_tables.html#==,CoreItem,CoreItem	proc `==`(a, b: CoreItem): bool		1392
nim	`<`	treestand/build_tables.html#<,CoreItem,CoreItem	proc `<`(a, b: CoreItem): bool		1399
nim	precomputeClosureCache	treestand/build_tables.html#precomputeClosureCache,SyntaxGrammar,LexicalGrammar,FirstSets	proc precomputeClosureCache(grammar: SyntaxGrammar; lexicalGrammar: LexicalGrammar;\n                       firstSets: FirstSets): ClosureCache		1512
nim	getTransitiveClosure	treestand/build_tables.html#getTransitiveClosure,SyntaxGrammar,StateKernels,ClosureCache,FirstSets	proc getTransitiveClosure(grammar: SyntaxGrammar; kernels: StateKernels;\n                     cache: ClosureCache; firstSets: FirstSets): StateKernels		1615
nim	FirstBetaCacheKey	treestand/build_tables.html#FirstBetaCacheKey	object FirstBetaCacheKey		1738
nim	hash	treestand/build_tables.html#hash,FirstBetaCacheKey	proc hash(cacheKey: FirstBetaCacheKey): Hash		1743
nim	closure	treestand/build_tables.html#closure,SyntaxGrammar,HashSet[LR1Item],FirstSets	proc closure(grammar: SyntaxGrammar; items: HashSet[LR1Item]; firstSets: FirstSets): HashSet[\n    LR1Item]		1750
nim	closureFast	treestand/build_tables.html#closureFast,SyntaxGrammar,HashSet[LR1Item],FirstSets,ClosurePrecomputation	proc closureFast(grammar: SyntaxGrammar; items: HashSet[LR1Item];\n            firstSets: FirstSets; precomputed: ClosurePrecomputation): HashSet[\n    LR1Item]		1856
nim	goto	treestand/build_tables.html#goto,SyntaxGrammar,HashSet[LR1Item],GrammarSymbol,FirstSets	proc goto(grammar: SyntaxGrammar; items: HashSet[LR1Item]; symbol: GrammarSymbol;\n     firstSets: FirstSets): HashSet[LR1Item]		1946
nim	buildCanonicalCollection	treestand/build_tables.html#buildCanonicalCollection,SyntaxGrammar,FirstSets,int	proc buildCanonicalCollection(grammar: SyntaxGrammar; firstSets: FirstSets;\n                         augmentedStartIndex: int = -1): tuple[\n    states: seq[HashSet[LR1Item]], stateMap: Table[seq[LR1Item], int],\n    transitions: seq[Table[GrammarSymbol, int]]]		2049
nim	buildCanonicalCollectionLALR	treestand/build_tables.html#buildCanonicalCollectionLALR,SyntaxGrammar,LexicalGrammar,FirstSets,int	proc buildCanonicalCollectionLALR(grammar: SyntaxGrammar;\n                             lexicalGrammar: LexicalGrammar;\n                             firstSets: FirstSets; augmentedStartIndex: int = -1): tuple[\n    states: seq[StateKernels], stateMap: Table[seq[CoreItem], seq[int]],\n    transitions: seq[Table[GrammarSymbol, int]]]		2182
nimgrp	==	treestand/build_tables.html#==-procs-all	proc		1353
nimgrp	<	treestand/build_tables.html#<-procs-all	proc		1360
nimgrp	hash	treestand/build_tables.html#hash-procs-all	proc		1344
