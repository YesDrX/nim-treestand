import treestand
import std/[strutils, options, strformat]

# ==============================================================================
# 1. Grammar Definition using tsGrammar
# ==============================================================================

# We define a grammar for simple arithmetic expressions.
# The `tsGrammar` macro generates the parser code in-place, including:
# - `parseMath(input: string): ParseNode`
# - `TerminalSymbol` and `NonTerminalSymbol` enums for identifying nodes.
tsGrammar "math":
  # Main entry point: a program is one or more expressions
  program     <- expression

  # Expression rules
  # We separate binary operations to handle them explicitly in AST
  expression  <- binary_op | primary

  # Binary operations: left-associative, precedence 1
  # The rule `seq(expr, op, expr)` creates a node with 3 children.
  binary_op   <- (expression * op * expression) ^ 1

  # Primary expressions
  primary     <- number | parens
  parens      <- lparen * expression * rparen

  # Lexical tokens
  number      <- token(re"-?\d+")
  op          <- token(re"[+\-*/]")
  lparen      <- token("(")
  rparen      <- token(")")
  
  # Configuration
  # We skip whitespace automatically
  extras      = token(re"\s+")

# ==============================================================================
# 2. Custom AST Definition
# ==============================================================================

type
  ExprKind = enum
    ekInt, ekBinary

  Expr = ref object
    case kind: ExprKind
    of ekInt:
      intVal: int
    of ekBinary:
      op: string
      left, right: Expr

proc `$`(e: Expr): string =
  case e.kind
  of ekInt: $e.intVal
  of ekBinary: fmt"({e.left} {e.op} {e.right})"

# ==============================================================================
# 3. Traversal Logic (ParseNode -> Custom AST)
# ==============================================================================

# The `tsGrammar` macro generates `TerminalSymbol` and `NonTerminalSymbol` enums
# which we can use to robustly identify node types.

proc toAst(node: ParseNode): Expr =
  # Handle Non-Terminals (rules defined in the grammar)
  if node.symbol.kind == skNonTerminal:
    let sym = NonTerminalSymbol(node.symbol.nonTerminalIndex)
    
    case sym
    of ntProgram:
      # efficient: just process the first child for this example, 
      # or returning a list if we supported multiple expressions.
      # usage: `program <- +expr` -> children are `expr` nodes.
      return toAst(node.children[0]) 

    of ntExpression:
      # `expression <- binary_op | primary`
      # The child is either a binary_op or a primary node
      return toAst(node.children[0])

    of ntBinary_op:
      # `binary_op <- expr * op * expr`
      # Children: [0]: expr, [1]: op, [2]: expr
      let left = toAst(node.children[0])
      # op is ntOp (named rule), so we need its child (tsOp)
      let opText = node.children[1].children[0].token.text
      let right = toAst(node.children[2])
      return Expr(kind: ekBinary, op: opText, left: left, right: right)

    of ntPrimary:
      # `primary <- number | parens`
      return toAst(node.children[0])

    of ntNumber:
      # `number <- token(...)` is a named rule, so it wraps the token.
      return toAst(node.children[0])

    of ntParens:
       # `parens <- lparen * expr * rparen`
       # Children: [0]: (, [1]: expr, [2]: )
       return toAst(node.children[1])
       
    else:
      # Should not happen if we handle all non-terminals that return Expr
      raise newException(ValueError, "Unexpected non-terminal: " & $sym)

  # Handle Terminals (lexical tokens)
  else: 
    let sym = TerminalSymbol(node.symbol.terminalIndex)
    
    case sym
    of tsNumber:
      return Expr(kind: ekInt, intVal: parseInt(node.token.text))
    else:
      # We shouldn't reach here for `op`, `lparen` etc because they are consumed 
      # by parent non-terminals (like ntBinaryOp).
      # If `toAst` is called on a raw token not handled above, it's an error for this AST.
      raise newException(ValueError, "Unexpected terminal: " & $sym)

# ==============================================================================
# 4. Main Execution
# ==============================================================================

when isMainModule:
  echo "Traversing CST to build AST..."
  
  # 1. Parse the input string into a Concrete Syntax Tree (ParseNode)
  # `parseMath` is generated by `tsGrammar "math"`
  let input = "1 + 2 * 3"
  let cst = parseMath(input)
  
  echo "Input: ", input
  
  if cst == nil:
    echo "Parsing failed!"
    quit(1)
    
  # 2. Convert CST to our custom AST
  try:
    let ast = toAst(cst)
    echo "AST:   ", ast
    
    # Verify correctness (simple check)
    # 1 + 2 * 3 -> ((1 + 2) * 3) because all ops have same precedence (1) and left assoc
    # output should be: ((1 + 2) * 3)
    if $ast == "((1 + 2) * 3)":
      echo "SUCCESS: AST matches expected precedence."
    else:
      echo "FAILURE: AST structure incorrect: " & $ast
      quit(1)
      
  except ValueError as e:
    echo "Error building AST: " & e.msg
    quit(1)
